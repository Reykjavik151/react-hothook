{"version":3,"file":"index.modern.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/hooks/useAsync.ts","../src/hooks/useCached.ts","../src/hooks/useCountdown.ts","../src/hooks/useDebouncedValue.ts","../src/hooks/useDeepCompareEffect.ts","../src/hooks/useFetch.ts","../src/hooks/useMount.ts","../src/hooks/usePrevious.ts","../src/hooks/useSpecificKeyExtractor.ts","../src/hooks/useStateWithCached.ts","../src/hooks/useStateWithPrevious.ts","../src/hooks/useUpdateEffect.ts","../src/hooks/useStateWithValidation.ts","../src/hooks/useToggle.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useEffect, useState } from 'react';\n\n/**\n * Async wrapper for async/await functions with Promise return\n * @param asyncFn should return promise\n * @returns data - expected value of \"asyncFn\", error - something went wrong (unexpected), loading - is asyncFn running\n */\nexport const useAsync = <TExpectedData>(asyncFn: () => Promise<TExpectedData>) => {\n  const [data, setData] = useState<TExpectedData | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n\n  useEffect(() => {\n    setData(null);\n    setError(null);\n    setIsLoading(false);\n\n    const fetchData = async () => {\n      setIsLoading(true);\n      try {\n        const result = await asyncFn();\n        setData(result);\n      } catch (err) {\n        setError(err as Error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [asyncFn]);\n\n  return { data, error, loading: isLoading };\n};\n","import { isEmpty, isNull, isUndefined } from 'lodash';\nimport { useEffect, useRef } from 'react';\n\n/**\n * Saves only not empty, not undefined and not null values\n * @param value any value to save\n * @returns the previous saved non-empty value\n */\nexport const useCached = <T>(value: T): T | undefined => {\n  const ref = useRef<T>();\n  useEffect(() => {\n    // Save only value, not empty / undefined / null\n    // Check all of these cases, because we may have `false` value to work with\n    if (!(isEmpty(value) || isUndefined(value) || isNull(value))) {\n      ref.current = value;\n    }\n  }, [value]);\n  return ref.current;\n};\n","import { useCallback, useEffect, useRef, useState } from 'react';\n\ntype UseCountdownOptions = {\n  initialRemainingTimeMs: number;\n  onEnd?: () => void;\n  onTick?: (timeLeft: number) => void;\n  countdownStepMs?: number;\n};\n\n/**\n * Hook to manage a countdown timer\n *\n * @param options initialRemainingTimeMs: number; onEnd?: () => void; onTick?: (timeLeft: number) => void; countdownStepMs?: number;\n * @returns set of functions and values to manage a countdown, including pause, resume, reset, and setting a new time\n *\n * @example\n * const {\n *   timeLeft,\n *   isPaused,\n *   resetCountdown,\n *   pauseCountdown,\n *   resumeCountdown,\n *   setNewRemainingTime,\n * } = useCountdown({\n *   initialRemainingTimeMs: 60000,\n *   countdownStepMs: 400,\n *   onTick: (currentTimeLeft) => { console.log('Countdown tick:', currentTimeLeft); },\n *   onEnd: () => { console.log('Countdown ended!'); },\n * });\n */\nexport const useCountdown = ({\n  initialRemainingTimeMs,\n  onEnd,\n  onTick,\n  countdownStepMs = 1000\n}: UseCountdownOptions) => {\n  const [timeLeft, setTimeLeft] = useState<number>(initialRemainingTimeMs);\n  const [isPaused, setIsPaused] = useState<boolean>(false);\n\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const startTimer = useCallback(() => {\n    if (!timerRef.current) {\n      timerRef.current = setInterval(() => {\n        setTimeLeft((prev) => {\n          if (prev <= countdownStepMs) {\n            clearInterval(timerRef.current!);\n            timerRef.current = null;\n            onEnd?.();\n            return 0;\n          }\n\n          const newTime = prev - countdownStepMs;\n          onTick?.(newTime);\n          return newTime;\n        });\n      }, countdownStepMs);\n    }\n  }, [countdownStepMs, onEnd, onTick]);\n  const stopTimer = useCallback(() => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n  }, []);\n\n  useEffect(() => {\n    // Launch countdown if there's time left and no interval is running\n    if (timeLeft > 0 && !isPaused && !timerRef.current) {\n      startTimer();\n    }\n\n    // Clean up on unmount\n    return () => {\n      stopTimer();\n    };\n  }, [timeLeft, isPaused, startTimer, stopTimer]);\n\n  const pauseCountdown = useCallback(() => {\n    setIsPaused(true);\n    stopTimer();\n  }, [stopTimer]);\n  const resumeCountdown = useCallback(() => {\n    setIsPaused(false);\n    startTimer();\n  }, [startTimer]);\n\n  const setNewRemainingTime = useCallback((newTimeMs: number) => {\n    setTimeLeft(newTimeMs);\n  }, []);\n  const resetCountdown = useCallback(() => {\n    setTimeLeft(0);\n    pauseCountdown();\n  }, [pauseCountdown]);\n\n  return {\n    isPaused,\n    timeLeft,\n    setNewRemainingTime,\n    resetCountdown,\n    pauseCountdown,\n    resumeCountdown\n  };\n};\n","import { useEffect, useState } from 'react';\n\n/**\n * Get value after a delay. If value changes within the delay period, the timeout gets cleared and restarted.\n * @param value current value to debounce\n * @param delay time to wait before updating the debounced value\n * @returns debounced value\n */\nexport const useDebouncedValue = <TValue>(value: TValue, delay: number) => {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value);\n      }, delay);\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      // This is how we prevent debounced value from updating if value is changed ...\n      // .. within the delay period. Timeout gets cleared and restarted.\n      return () => {\n        clearTimeout(handler);\n      };\n    },\n    [value, delay] // Only re-call effect if value or delay changes\n  );\n\n  return debouncedValue;\n};\n","import { isEqual } from 'lodash';\n// eslint-disable-next-line no-unused-vars\nimport { DependencyList, useEffect, useRef } from 'react';\n\ntype EffectCallback = () => void;\n\n/**\n * Allows a component to run an effect only when the dependencies have changed using a deep comparison instead of a shallow comparison\n * @param callback function that must be called when the deps change\n * @param dependencies deep comparison dependencies that will be used to trigger the callback\n */\nexport const useDeepCompareEffect = (callback: EffectCallback, dependencies: DependencyList): void => {\n  const currentDependenciesRef = useRef<DependencyList | null>(null);\n\n  if (!isEqual(currentDependenciesRef.current, dependencies)) {\n    currentDependenciesRef.current = dependencies;\n  }\n\n  useEffect(callback, [currentDependenciesRef.current]);\n};\n","import { useAsync } from './useAsync';\n\nconst DEFAULT_HEADERS = {\n  'Content-Type': 'application/json'\n};\n\n/**\n * Hook to fetch data from an API\n * @param url fetch url\n * @param options fetch options\n * @returns Promise with the response body\n */\nexport const useFetch = (url: string, options: RequestInit = {}) =>\n  useAsync(() =>\n    fetch(url, {\n      ...options,\n      headers: { ...DEFAULT_HEADERS, ...(options.headers ?? {}) }\n    }).then((res) => {\n      if (res.ok) {\n        return res.json();\n      }\n\n      return res.json().then((json) => {\n        throw new Error(json);\n      });\n    })\n  );\n","import { useEffect } from 'react';\n\n/**\n * Empty dependency array useEffect\n * @param func the main function to run on mountion of the component\n * @returns useEffect with empty dependency array\n */\nexport const useMount = (func: () => void) => useEffect(func, []);\n","import { useEffect, useRef } from 'react';\n\n/**\n * Saves the previous state of the value\n * @param value the current value from the useState (usually) to save its prev value\n * @param valuesToIgnore an array of values to ignore when saving the previous value\n * @returns the previous saved value\n */\nexport const usePrevious = <T>(value: T, valuesToIgnore: Array<T> = []): T | undefined => {\n  const ref = useRef<T>();\n  useEffect(() => {\n    if (valuesToIgnore.includes(value)) return;\n    ref.current = value;\n  }, [value, valuesToIgnore]);\n  return ref.current;\n};\n","import { useCallback } from 'react';\n\n/**\n * Creates a key extractor function for React mapping that uses a specific field of the item as a key\n * @param prefix prefix for the key\n * @param field field of the item to use as a key\n * @returns key extractor function for React mapping\n */\nexport const useSpecificKeyExtractor = <TItem>(prefix: string, field: keyof TItem) =>\n  useCallback((item: TItem, index: number) => `${prefix}-${item[field]}-${index}`, [prefix, field]);\n","// eslint-disable-next-line no-unused-vars\nimport React, { SetStateAction, useState } from 'react';\n\nimport { useCached } from './useCached';\n\n/**\n * Extends React.useState with a cached non-empty state as a third output value of array\n * @param initialValue initial value as the third value of the state and prevState\n * @returns [state, setState, cachedState] - state is the current state (including undefined and null), setState is the setter for the state, cachedState is the latest non-empty state\n */\nexport const useStateWithCached = <T>(initialValue: T): [T, React.Dispatch<SetStateAction<T>>, T | undefined] => {\n  const [state, setState] = useState<T>(initialValue);\n  const cachedState = useCached(state);\n\n  return [state, setState, cachedState];\n};\n","// eslint-disable-next-line no-unused-vars\nimport React, { SetStateAction, useState } from 'react';\n\nimport { usePrevious } from './usePrevious';\n\n/**\n * Extends React.useState with a previous state as a first output value of array\n * @param initialValue initial value as the third value of the state and prevState\n * @returns [state, setState, prevState] - state is the current state, setState is the setter for the state, prevState is the previous state,\n */\nexport const useStateWithPrevious = <T>(initialValue: T): [T, React.Dispatch<SetStateAction<T>>, T | undefined] => {\n  const [state, setState] = useState<T>(initialValue);\n  const prevState = usePrevious(state);\n\n  return [state, setState, prevState];\n};\n","import { useEffect, useRef } from 'react';\n\n/**\n * Extended useEffect - skip first function call on mount and leave only update calls\n * @param callback function that must be called when the deps change and skip first time as main purpose\n * @param deps dependencies that will be used to trigger the callback\n */\nexport const useUpdateEffect = (callback: () => void, deps: React.DependencyList) => {\n  const firstRenderRef = useRef(true);\n\n  useEffect(() => {\n    if (firstRenderRef.current) {\n      firstRenderRef.current = false;\n      return;\n    }\n\n    // eslint-disable-next-line consistent-return\n    return callback();\n  }, deps);\n};\n","// eslint-disable-next-line no-unused-vars\nimport React, { SetStateAction, useState } from 'react';\n\nimport { useUpdateEffect } from './useUpdateEffect';\n\n/**\n * Extends React.useState with a validator function (second parameter) that validates the state and returns a boolean as a third value of the output array.\n * @param initialValue initial value of the state\n * @param validator function-validator that validates the state after each state update\n * @returns [state, setState, isValid] - state is the current state, setState is the setter for the state, isValid is a boolean that indicates if the state passes the validation\n */\nexport const useStateWithValidation = <T>(\n  initialValue: T,\n  validator: (value: T) => boolean\n): [T, React.Dispatch<SetStateAction<T>>, boolean] => {\n  const [state, setState] = useState<T>(initialValue);\n  const [isValid, setIsValid] = useState(validator(state));\n\n  useUpdateEffect(() => {\n    setIsValid(validator(state));\n  }, [state, validator]);\n\n  return [state, setState, isValid];\n};\n","import { useCallback, useState } from 'react';\n\n/**\n * Extended useState for boolean value with exported toggle function\n * @param defaultValue boolean value to set as default\n * @returns [isValue, toggleValue] - isValue is the current boolean value, toggleValue is the toggle setter for the boolean value without any params\n */\nexport const useToggle = (defaultValue: boolean): [boolean, () => void] => {\n  const [isValue, setIsValue] = useState(defaultValue);\n\n  const toggleValue = useCallback(() => setIsValue((prevState) => !prevState), []);\n\n  return [isValue, toggleValue];\n};\n"],"names":["useAsync","asyncFn","_useState","useState","data","setData","_useState2","error","setError","_useState3","isLoading","setIsLoading","useEffect","fetchData","_temp","_finallyRethrows","_catch","Promise","resolve","then","result","err","_wasThrown","_result","e","reject","loading","useCached","value","ref","useRef","isEmpty","isUndefined","isNull","current","useCountdown","_ref","initialRemainingTimeMs","onEnd","onTick","_ref$countdownStepMs","countdownStepMs","timeLeft","setTimeLeft","isPaused","setIsPaused","timerRef","startTimer","useCallback","setInterval","prev","clearInterval","newTime","stopTimer","pauseCountdown","resumeCountdown","setNewRemainingTime","newTimeMs","resetCountdown","useDebouncedValue","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useDeepCompareEffect","callback","dependencies","currentDependenciesRef","isEqual","DEFAULT_HEADERS","useFetch","url","options","_options$headers","fetch","_extends","headers","res","ok","json","Error","useMount","func","usePrevious","valuesToIgnore","includes","useSpecificKeyExtractor","prefix","field","item","index","useStateWithCached","initialValue","state","setState","cachedState","useStateWithPrevious","prevState","useUpdateEffect","deps","firstRenderRef","useStateWithValidation","validator","isValid","setIsValid","useToggle","defaultValue","isValue","setIsValue","toggleValue"],"mappings":"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"}